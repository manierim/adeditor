{"version":3,"sources":["webpack:///./node_modules/core-js/modules/es.string.match.js","webpack:///./src/utils/Adaptors/configSave.js"],"names":["fixRegExpWellKnownSymbolLogic","anObject","toLength","requireObjectCoercible","advanceStringIndex","regExpExec","MATCH","nativeMatch","maybeCallNative","regexp","O","this","matcher","undefined","call","RegExp","String","res","done","value","rx","S","global","fullUnicode","unicode","lastIndex","result","A","n","matchStr","parser","xml","fileName","root","mapname","response","error","id","x","y","z","outs","ins","markers","AutoDrive","MapName","match","length","waypoints","split","out","mapmarker","key","marker","push","index","parseInt","name","folder","group","wptsArray","wptsRoot","indexMap","map","wpt","links","list","idx","indexOf","join","existingOuts","existingIns","defaultFolder","forEach","xml2js","require","builder","Builder","headless","xmldec","version","encoding","standalone","buildObject"],"mappings":"kHACA,IAAIA,EAAgC,EAAQ,QACxCC,EAAW,EAAQ,QACnBC,EAAW,EAAQ,QACnBC,EAAyB,EAAQ,QACjCC,EAAqB,EAAQ,QAC7BC,EAAa,EAAQ,QAGzBL,EAA8B,QAAS,GAAG,SAAUM,EAAOC,EAAaC,GACtE,MAAO,CAGL,SAAeC,GACb,IAAIC,EAAIP,EAAuBQ,MAC3BC,OAAoBC,GAAVJ,OAAsBI,EAAYJ,EAAOH,GACvD,YAAmBO,IAAZD,EAAwBA,EAAQE,KAAKL,EAAQC,GAAK,IAAIK,OAAON,GAAQH,GAAOU,OAAON,KAI5F,SAAUD,GACR,IAAIQ,EAAMT,EAAgBD,EAAaE,EAAQE,MAC/C,GAAIM,EAAIC,KAAM,OAAOD,EAAIE,MAEzB,IAAIC,EAAKnB,EAASQ,GACdY,EAAIL,OAAOL,MAEf,IAAKS,EAAGE,OAAQ,OAAOjB,EAAWe,EAAIC,GAEtC,IAAIE,EAAcH,EAAGI,QACrBJ,EAAGK,UAAY,EACf,IAEIC,EAFAC,EAAI,GACJC,EAAI,EAER,MAAwC,QAAhCF,EAASrB,EAAWe,EAAIC,IAAc,CAC5C,IAAIQ,EAAWb,OAAOU,EAAO,IAC7BC,EAAEC,GAAKC,EACU,KAAbA,IAAiBT,EAAGK,UAAYrB,EAAmBiB,EAAGnB,EAASkB,EAAGK,WAAYF,IAClFK,IAEF,OAAa,IAANA,EAAU,KAAOD,Q,mNCxCTG,E,WAInB,WAAYC,EAAKC,GAAU,sIACzBrB,KAAKoB,IAAMA,EACXpB,KAAKqB,SAAWA,E,4CAGlB,WACE,IAWIC,EACAC,EAZAC,EAAW,CACbC,MAAO,KACPC,GAAI,KACJC,EAAG,KACHC,EAAG,KACHC,EAAG,KACHC,KAAM,KACNC,IAAK,KACLC,QAAS,MAMX,GAAIhC,KAAKoB,IAAIa,UAAUC,QACrBX,EAAUvB,KAAKoB,IAAIa,UAAUC,YACxB,CAGL,GAFAX,EAAUvB,KAAKqB,SAASc,MAAM,+BAER,GAAlBZ,EAAQa,OAKV,OAFAZ,EAASC,MACP,8BAAgCzB,KAAKqB,SAAW,aAC3CG,EAJPD,EAAUA,EAAQ,GAQtB,GAAIvB,KAAKoB,IAAIa,UAAUI,UACrBf,EAAOtB,KAAKoB,IAAIa,cACX,CACL,IAAKjC,KAAKoB,IAAIa,UAAUV,GAGtB,OAFAC,EAASC,MACP,kBAAoBF,EAAU,4BACzBC,EAETF,EAAOtB,KAAKoB,IAAIa,UAAUV,GAAS,GAKrC,GAFAvB,KAAKuB,QAAUA,GAEVD,EAAKe,WAAuC,IAA1Bf,EAAKe,UAAUD,OAEpC,OADAZ,EAASC,MAAQ,wBACVD,EAWT,GARAA,EAASE,GAAKJ,EAAKe,UAAU,GAAGX,GAAG,GAAGY,MAAM,KAC5Cd,EAASG,EAAIL,EAAKe,UAAU,GAAGV,EAAE,GAAGW,MAAM,KAC1Cd,EAASI,EAAIN,EAAKe,UAAU,GAAGT,EAAE,GAAGU,MAAM,KAC1Cd,EAASK,EAAIP,EAAKe,UAAU,GAAGR,EAAE,GAAGS,MAAM,KAE1Cd,EAASM,KAAOR,EAAKe,UAAU,GAAGE,IAAI,GAAGD,MAAM,KAC/Cd,EAASO,IAAMT,EAAKe,UAAU,GAAG,YAAY,GAAGC,MAAM,KAGpDd,EAASE,GAAGU,SAAWZ,EAASG,EAAES,QAClCZ,EAASG,EAAES,SAAWZ,EAASI,EAAEQ,QACjCZ,EAASI,EAAEQ,SAAWZ,EAASK,EAAEO,QACjCZ,EAASK,EAAEO,SAAWZ,EAASM,KAAKM,QACpCZ,EAASM,KAAKM,SAAWZ,EAASO,IAAIK,OAsBtC,OApBAZ,EAASC,MACP,OACAD,EAASE,GAAGU,OADZ,SAIAZ,EAASG,EAAES,OAJX,SAOAZ,EAASI,EAAEQ,OAPX,SAUAZ,EAASK,EAAEO,OAVX,WAaAZ,EAASM,KAAKM,OAbd,WAgBAZ,EAASO,IAAIK,OAhBb,8BAmBKZ,EAKT,GAFAA,EAASQ,QAAU,GAEfV,EAAKkB,UACP,IAAK,IAAMC,KAAOnB,EAAKkB,UAAU,GAAI,CACnC,IAAME,EAASpB,EAAKkB,UAAU,GAAGC,GAAK,GACtCjB,EAASQ,QAAQW,KAAK,CACpBC,MAAOC,SAASH,EAAOhB,GAAG,IAC1BoB,KAAMJ,EAAOI,KAAK,GAClBC,OAAQL,EAAOM,MAAM,KAI3B,OAAOxB,I,+BAGT,SAAkByB,EAAWjB,GAAS,WAChCkB,EAAWlD,KAAKoB,IAAIa,UAAUjC,KAAKuB,SAAS,GAAGc,UAAU,GAEzDc,EAAWF,EAAUG,KAAI,SAACC,GAAD,OAASR,SAASQ,EAAIT,UASnD,SAASU,EAAMC,GAKb,OAJAA,EAAOA,EAAKH,KAAI,SAACI,GAAD,OAASL,EAASM,QAAQD,GAAO,KAC5CD,EAAKnB,QACRmB,EAAKZ,MAAM,GAENY,EAZTL,EAAS,MAAQD,EACdG,KAAI,SAACC,GAAD,OAASF,EAASM,QAAQJ,EAAIT,OAAS,KAC3Cc,KAAK,KACRR,EAAS,KAAOD,EAAUG,KAAI,SAACC,GAAD,OAASA,EAAI1B,KAAG+B,KAAK,KACnDR,EAAS,KAAOD,EAAUG,KAAI,SAACC,GAAD,OAASA,EAAIzB,KAAG8B,KAAK,KACnDR,EAAS,KAAOD,EAAUG,KAAI,SAACC,GAAD,OAASA,EAAIxB,KAAG6B,KAAK,KAUnDR,EAAS,OAASD,EACfG,KAAI,SAACC,GAAD,OAASC,EAAMD,EAAIM,gBAAgBD,KAAK,QAC5CA,KAAK,KACRR,EAAS,YAAcD,EACpBG,KAAI,SAACC,GAAD,OAASC,EAAMD,EAAIO,eAAeF,KAAK,QAC3CA,KAAK,KAER,IAAIG,EAAgB,MAEhB7B,EAAQI,QACVpC,KAAKoB,IAAIa,UAAUjC,KAAKuB,SAAS,GAAGiB,UAAY,GAChDR,EAAQ8B,SAAQ,SAACpB,EAAQc,GACvB,EAAKpC,IAAIa,UAAU,EAAKV,SAAS,GAAGiB,UAAU,MAAQgB,EAAM,IAAM,CAChE9B,GAAIyB,EAASM,QAAQZ,SAASH,EAAOW,IAAIT,QAAU,EACnDE,KAAMJ,EAAOI,KACbE,MAAON,EAAOK,OAASL,EAAOK,OAASc,OAIvC7D,KAAKoB,IAAIa,UAAUjC,KAAKuB,SAAS,GAAGiB,kBAC/BxC,KAAKoB,IAAIa,UAAUjC,KAAKuB,SAAS,GAAGiB,UAI/C,IAAIuB,EAASC,EAAQ,QAEjBC,EAAU,IAAIF,EAAOG,QAAQ,CAC/BC,UAAU,EACVC,OAAQ,CACNC,QAAS,MACTC,SAAU,QACVC,YAAY,KAIhB,OAAON,EAAQO,YAAYxE,KAAKoB,S","file":"js/chunk-7e07bcb6.50b13ba3.js","sourcesContent":["'use strict';\nvar fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');\nvar anObject = require('../internals/an-object');\nvar toLength = require('../internals/to-length');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\nvar advanceStringIndex = require('../internals/advance-string-index');\nvar regExpExec = require('../internals/regexp-exec-abstract');\n\n// @@match logic\nfixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {\n  return [\n    // `String.prototype.match` method\n    // https://tc39.es/ecma262/#sec-string.prototype.match\n    function match(regexp) {\n      var O = requireObjectCoercible(this);\n      var matcher = regexp == undefined ? undefined : regexp[MATCH];\n      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n    },\n    // `RegExp.prototype[@@match]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match\n    function (regexp) {\n      var res = maybeCallNative(nativeMatch, regexp, this);\n      if (res.done) return res.value;\n\n      var rx = anObject(regexp);\n      var S = String(this);\n\n      if (!rx.global) return regExpExec(rx, S);\n\n      var fullUnicode = rx.unicode;\n      rx.lastIndex = 0;\n      var A = [];\n      var n = 0;\n      var result;\n      while ((result = regExpExec(rx, S)) !== null) {\n        var matchStr = String(result[0]);\n        A[n] = matchStr;\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n        n++;\n      }\n      return n === 0 ? null : A;\n    }\n  ];\n});\n","export default class parser {\n  xml;\n  fileName;\n  mapname;\n  constructor(xml, fileName) {\n    this.xml = xml;\n    this.fileName = fileName;\n  }\n\n  parse() {\n    let response = {\n      error: null,\n      id: null,\n      x: null,\n      y: null,\n      z: null,\n      outs: null,\n      ins: null,\n      markers: null,\n    };\n\n    let root;\n    let mapname;\n\n    if (this.xml.AutoDrive.MapName) {\n      mapname = this.xml.AutoDrive.MapName;\n    } else {\n      mapname = this.fileName.match(/^AutoDrive_(.*)_config.xml$/);\n\n      if (mapname.length == 2) {\n        mapname = mapname[1];\n      } else {\n        response.error =\n          \"Could not find map name in \" + this.fileName + \" filename.\";\n        return response;\n      }\n    }\n\n    if (this.xml.AutoDrive.waypoints) {\n      root = this.xml.AutoDrive;\n    } else {\n      if (!this.xml.AutoDrive[mapname]) {\n        response.error =\n          \"Could not find \" + mapname + \" element in xml document.\";\n        return response;\n      }\n      root = this.xml.AutoDrive[mapname][0];\n    }\n\n    this.mapname = mapname;\n\n    if (!root.waypoints || root.waypoints.length !== 1) {\n      response.error = \"Cannot find waypoints\";\n      return response;\n    }\n\n    response.id = root.waypoints[0].id[0].split(\",\");\n    response.x = root.waypoints[0].x[0].split(\",\");\n    response.y = root.waypoints[0].y[0].split(\",\");\n    response.z = root.waypoints[0].z[0].split(\",\");\n\n    response.outs = root.waypoints[0].out[0].split(\";\");\n    response.ins = root.waypoints[0][\"incoming\"][0].split(\";\");\n\n    if (\n      response.id.length !== response.x.length ||\n      response.x.length !== response.y.length ||\n      response.y.length !== response.z.length ||\n      response.z.length !== response.outs.length ||\n      response.outs.length !== response.ins.length\n    ) {\n      response.error =\n        \"id (\" +\n        response.id.length +\n        \"), \" +\n        \"x (\" +\n        response.x.length +\n        \"), \" +\n        \"y (\" +\n        response.y.length +\n        \"), \" +\n        \"z (\" +\n        response.z.length +\n        \"), \" +\n        \"out (\" +\n        response.outs.length +\n        \"), \" +\n        \"ins (\" +\n        response.ins.length +\n        \"), \" +\n        \"data length not coherent\";\n      return response;\n    }\n\n    response.markers = [];\n\n    if (root.mapmarker) {\n      for (const key in root.mapmarker[0]) {\n        const marker = root.mapmarker[0][key][0];\n        response.markers.push({\n          index: parseInt(marker.id[0]),\n          name: marker.name[0],\n          folder: marker.group[0],\n        });\n      }\n    }\n    return response;\n  }\n\n  getContentForSave(wptsArray, markers) {\n    let wptsRoot = this.xml.AutoDrive[this.mapname][0].waypoints[0];\n\n    let indexMap = wptsArray.map((wpt) => parseInt(wpt.index));\n\n    wptsRoot[\"id\"] = wptsArray\n      .map((wpt) => indexMap.indexOf(wpt.index) + 1)\n      .join(\",\");\n    wptsRoot[\"x\"] = wptsArray.map((wpt) => wpt.x).join(\",\");\n    wptsRoot[\"y\"] = wptsArray.map((wpt) => wpt.y).join(\",\");\n    wptsRoot[\"z\"] = wptsArray.map((wpt) => wpt.z).join(\",\");\n\n    function links(list) {\n      list = list.map((idx) => indexMap.indexOf(idx) + 1);\n      if (!list.length) {\n        list.push(-1);\n      }\n      return list;\n    }\n\n    wptsRoot[\"out\"] = wptsArray\n      .map((wpt) => links(wpt.existingOuts()).join(\",\"))\n      .join(\";\");\n    wptsRoot[\"incoming\"] = wptsArray\n      .map((wpt) => links(wpt.existingIns()).join(\",\"))\n      .join(\";\");\n\n    let defaultFolder = \"All\";\n\n    if (markers.length) {\n      this.xml.AutoDrive[this.mapname][0].mapmarker = {};\n      markers.forEach((marker, idx) => {\n        this.xml.AutoDrive[this.mapname][0].mapmarker[\"mm\" + (idx + 1)] = {\n          id: indexMap.indexOf(parseInt(marker.wpt.index)) + 1,\n          name: marker.name,\n          group: marker.folder ? marker.folder : defaultFolder,\n        };\n      });\n    } else {\n      if (this.xml.AutoDrive[this.mapname][0].mapmarker) {\n        delete this.xml.AutoDrive[this.mapname][0].mapmarker;\n      }\n    }\n\n    let xml2js = require(\"xml2js\");\n\n    let builder = new xml2js.Builder({\n      headless: false,\n      xmldec: {\n        version: \"1.0\",\n        encoding: \"UTF-8\",\n        standalone: false,\n      },\n    });\n\n    return builder.buildObject(this.xml);\n  }\n}\n"],"sourceRoot":""}